# 作用域

## 什么是作用域

&emsp;&emsp;基本上所有语言中都具备一个功能,可以定义一个变量并在之后对这个变量进行赋值和修改。正式这种存储和访问变量的能力给了程序高度的灵活。没有这个能力，程序虽然能执行一些简单的任务，但是没有那么的灵活，会显得有一些死板。但是将变量引入程序中同时会来带一些问题：变量存储在哪里，什么时候应用它。 怎么解决这些问题，需要引入一套合理的规则去存储变量以及在合适的时候去引用它，这一套规则就称之为作用域。

## 编译原理

&emsp;&emsp;传统的语言像 Java，C++等一些语言中程序的编译分为三步：

- 分词/词法分析（Tokenizing/Lexing）

  &emsp;&emsp;这个过程会讲字符组成的字符串分解成为对编程语言来说有意义的代码块，这些代码块称为词法单元。例如 var a = 2;这段程序通常会被分解城["var","a","=","2"]。

> 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。

- 解析/语法分析（Parsing）

  &emsp;&emsp;这个过程中会讲词法单元装换成一个元素逐级嵌套所组成的代表了程序语法结构的树。这树被称为抽象语法树（Abstract Syntax Tree,AST）。

- 代码生成

  &emsp;&emsp;将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2；的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

&emsp;&emsp;比起这些传统的编程语言，JavaScript 引擎要复杂的多，例如，会在词法分析和代码生成的时候对特定步骤来对运行性能进行优化，包括对冗余元素进行优化。

&emsp;&emsp;首先 js 是一门动态语言，JavaScript 引擎没有那么多时间来进行优化，与其他语言不同，JavaScript 编译过程不是发生在之前构建的。

&emsp;&emsp;对 JavaScript 来说大部分情况下编译是在执行前那么几微秒。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。

&emsp;&emsp;简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对 var a = 2；这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

## 词法作用域

> 作用域共有两种主要的工作模型,词法作用域和动态作用域，动态作用域是更具调用是的位置来动态的决定当前的作用域，跟定义时的位置没有关系，简单的说动态作用域是根据当前的调用栈来决定作用域范围，跟 js 中 this 有一些想象，当然 this 也不是动态作用域的。最后在 js 中使用的是词法作用域

大部分语言的编译第一个阶段就是分词，这个过程会将字符串代码进行拆分。这个过程中会对代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。这个理念就是对于词法作用语的理念由来。简单的说，词法作用域就是定义在词法分析阶段的作用域。即是那个变量定义在代码中的位置，由书写代码的时候决定了变量的作用域，和块作用域的位置。

> 块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

下面一段代码

```js
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2); // 2 , 4 , 12
```

来看一下以上代码的作用域:

- foo 函数形成了一个作用域,其中有两个标识符: a,b,bar
- bar 函数形成了一个作用域,其中有一个标识符: c
- 全局作用域 在游览器中是 windows 在 node 环境中是 globe,其中只有一个标识符:foo

这些变量从我们写出来的时候已经决定了位置，和作用域的范围，他们是逐级包含的，对于一个变量的查找是逐级向上的，如在 bar 作用域中查找 a 变量的时候，在当前作用域中没有查找到，则会向上一级作用域进行查找，在上述代码中向上查找便是在 foo 函数的作用域中查询，在其中发现了 a 变量，查询到此为止不会再向上进行查找了，如果在全局作用域中也存在 a 变量则会被 foo 中的 a 变量给遮蔽这就叫遮蔽效应。当然作用域是严格包含的，不存在可以跨过边界的，例如不会存在一个变量同时存在与两个同级的作用域中的。

> 函数不管是在哪里调用的，如何被调用的它的作用域都于此无关，由函数的书写位置有关

### 欺骗词法作用域

在 js 中也有一些方法可以欺骗词法作用域，我们说到了词法作用域是在词法分析的时候决定的，那么在词法分析的时候有一段不执行的代码，或者说有一个方法可以不在词法分析的时候执行，那么就不存在词法作用域了。

- 1 eval

在 js 中 eval 可以接收一个字符串，在运行的时候吧字符串当成一段 js 代码在当前位置运行，

```js
function foo(str, a) {
  eval(str);
  console.log(a, b);
}
var b = 2;
foo('var b=3', 1); // 1,3
```

上述这段代码，var b=3 是在代码执行阶段运行的在 foo 作用域中重新定义了一个 b 变量，遮蔽了同名的全局变量 b，使得查询的时候找不到全局变量，无论什么情况 eval 可以进行修改书写时候的词法作用域

new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比 eval(..)略微安全一些，但也要尽量避免使用。

> 在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

- with

JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是 with 关键字。可以有很多方法来解释 with，在这里我选择从这个角度来解释它：它如何同被它所影响的词法作用域进行交互。

> JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..)或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。所有在欺骗词法作用域的时候也会带来一些性能上的问题
